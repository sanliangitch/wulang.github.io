<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ClickHouse运维SQL</title>
    <link href="/2022/11/11/ClickHouse%E8%BF%90%E7%BB%B4SQL/"/>
    <url>/2022/11/11/ClickHouse%E8%BF%90%E7%BB%B4SQL/</url>
    
    <content type="html"><![CDATA[<h3 id="常用运维SQL语句"><a href="#常用运维SQL语句" class="headerlink" title="常用运维SQL语句"></a>常用运维SQL语句</h3><ul><li>当前连接数 </br><br>  CH 对外暴露的原生接口分为 TCP 和 HTTP 两类，通过 system.metrics 即可查询当前的 TCP、HTTP 与内部副本的连接数。</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> *<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">system</span>.metrics<br><span class="hljs-keyword">WHERE</span> metric <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Connection&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>当前正在执行的查询</br><br>  通过 system.processes 可以查询目前正在执行的查询</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <br>    query_id, <br>    <span class="hljs-keyword">user</span>, <br>    address, <br>    query<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">system</span>.processes<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> query_id <span class="hljs-keyword">ASC</span><br></code></pre></td></tr></table></figure><ul><li>终止查询</br><br>  通过 KILL QUERY 语句，可以终止正在执行的查询</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">KILL</span> QUERY <span class="hljs-built_in">WHERE</span> query_id = <span class="hljs-string">&#x27;query_id&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>查询ALTER DELETE 和 ALTER UPDATE</br><br>  对于 Mutation 操作， ClickHouse 专门提供了 system.mutations 用于查询</li></ul><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">SELECT <br><span class="hljs-built_in">    database,</span> <br><span class="hljs-built_in">    table,</span> <br><span class="hljs-built_in">    mutation_id,</span> <br><span class="hljs-built_in">    command,</span> <br><span class="hljs-built_in">    create_time,</span> <br>    is_done<br>FROM system.mutations<br></code></pre></td></tr></table></figure><ul><li>存储空间统计</br><br>  查询 CH 各个存储路径的空间</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <br>    <span class="hljs-type">name</span>, <br>    <span class="hljs-type">path</span>, <br>    formatReadableSize(free_space) <span class="hljs-keyword">AS</span> free, <br>    formatReadableSize(total_space) <span class="hljs-keyword">AS</span> total, <br>    formatReadableSize(keep_free_space) <span class="hljs-keyword">AS</span> reserved<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">system</span>.disks<br></code></pre></td></tr></table></figure><ul><li>各数据库占用空间统计</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <br>    <span class="hljs-keyword">database</span>, <br>    formatReadableSize(<span class="hljs-built_in">sum</span>(bytes_on_disk)) <span class="hljs-keyword">AS</span> on_disk<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">system</span>.parts<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">database</span><br></code></pre></td></tr></table></figure><ul><li>个列字段占用空间统计</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <br>    <span class="hljs-keyword">database</span>, <br>    <span class="hljs-keyword">table</span>, <br>    <span class="hljs-keyword">column</span>, <br>    <span class="hljs-keyword">any</span>(<span class="hljs-keyword">type</span>), <br>    sum(column_data_compressed_bytes) <span class="hljs-keyword">AS</span> compressed, <br>    sum(column_data_uncompressed_bytes) <span class="hljs-keyword">AS</span> uncompressed, <br>    round(uncompressed / compressed, <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> ratio, <br>    compressed / sum(<span class="hljs-keyword">rows</span>) <span class="hljs-keyword">AS</span> bpr, <br>    sum(<span class="hljs-keyword">rows</span>)<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">system</span>.parts_columns<br><span class="hljs-keyword">WHERE</span> active <span class="hljs-keyword">AND</span> <span class="hljs-keyword">database</span> != <span class="hljs-string">&#x27;system&#x27;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <br>    <span class="hljs-keyword">database</span>, <br>    <span class="hljs-keyword">table</span>, <br>    <span class="hljs-keyword">column</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <br>    <span class="hljs-keyword">database</span> <span class="hljs-keyword">ASC</span>, <br>    <span class="hljs-keyword">table</span> <span class="hljs-keyword">ASC</span>, <br>    <span class="hljs-keyword">column</span> <span class="hljs-keyword">ASC</span><br></code></pre></td></tr></table></figure><ul><li>慢查询</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <br>    <span class="hljs-keyword">user</span>, <br>    client_hostname <span class="hljs-keyword">AS</span> host, <br>    client_name <span class="hljs-keyword">AS</span> client, <br>    formatDateTime(query_start_time, <span class="hljs-string">&#x27;%T&#x27;</span>) <span class="hljs-keyword">AS</span> started, <br>    query_duration_ms / <span class="hljs-number">1000</span> <span class="hljs-keyword">AS</span> sec, <br>    <span class="hljs-built_in">round</span>(memory_usage / <span class="hljs-number">1048576</span>) <span class="hljs-keyword">AS</span> MEM_MB, <br>    result_rows <span class="hljs-keyword">AS</span> RES_CNT, <br>    result_bytes / <span class="hljs-number">1048576</span> <span class="hljs-keyword">AS</span> RES_MB, <br>    read_rows <span class="hljs-keyword">AS</span> R_CNT, <br>    <span class="hljs-built_in">round</span>(read_bytes / <span class="hljs-number">1048576</span>) <span class="hljs-keyword">AS</span> R_MB, <br>    written_rows <span class="hljs-keyword">AS</span> W_CNT, <br>    <span class="hljs-built_in">round</span>(written_bytes / <span class="hljs-number">1048576</span>) <span class="hljs-keyword">AS</span> W_MB, <br>    query<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">system</span>.query_log<br><span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">type</span> = <span class="hljs-number">2</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> query_duration_ms <span class="hljs-keyword">DESC</span><br><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><ul><li>副本预警监控</br></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">SELECT database, table, is_leader, total_replicas, active_replicas <br>  FROM system.replicas <br> WHERE is_readonly <br>    <span class="hljs-keyword">OR </span>is_session_expired <br>    <span class="hljs-keyword">OR </span>future_parts &gt; <span class="hljs-number">30</span> <br>    <span class="hljs-keyword">OR </span>parts_to_check &gt; <span class="hljs-number">20</span> <br>    <span class="hljs-keyword">OR </span>queue_size &gt; <span class="hljs-number">30</span> <br>    <span class="hljs-keyword">OR </span><span class="hljs-keyword">inserts_in_queue </span>&gt; <span class="hljs-number">20</span> <br>    <span class="hljs-keyword">OR </span>log_max_index - log_pointer &gt; <span class="hljs-number">20</span> <br>    <span class="hljs-keyword">OR </span>total_replicas &lt; <span class="hljs-number">2</span> <br>    <span class="hljs-keyword">OR </span>active_replicas &lt; total_replicas<br></code></pre></td></tr></table></figure><h3 id="解决数据一致性"><a href="#解决数据一致性" class="headerlink" title="解决数据一致性"></a>解决数据一致性</h3><ul><li>一种是在写入数据后，立刻通过</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">OPTIMIZE <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">PARTITION</span> part <span class="hljs-keyword">FINAL</span><br>eg：optimize <span class="hljs-keyword">table</span> sic_member_middle_label <span class="hljs-keyword">final</span>;<br></code></pre></td></tr></table></figure><p>强制触发新写入分区的合并动作。</p><ul><li>一种是通过 GROUP BY 查询 + 过滤实现。argMax 函数登场</br><br>argMax 函数的参数如下所示，它能够按照 field2 的最大值取 field1 的值。<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">arg<span class="hljs-constructor">Max(<span class="hljs-params">field1</span>，<span class="hljs-params">field2</span>)</span><br></code></pre></td></tr></table></figure></li><li>还有一种是通过 FINAL 查询实现，即在查询语句后增加 FINAL 修饰符，这样在查询的过程中将会执行 Merge 的特殊逻辑(例如数据去重，预聚合等)。</li></ul><h3 id="如何在-ClickHouse-中避免深度分页问题"><a href="#如何在-ClickHouse-中避免深度分页问题" class="headerlink" title="如何在 ClickHouse 中避免深度分页问题"></a>如何在 ClickHouse 中避免深度分页问题</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">在SQL最后加入：<br>settings distributed_group_by_no_merge <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="利用Null引擎和物化视图构建数据管道"><a href="#利用Null引擎和物化视图构建数据管道" class="headerlink" title="利用Null引擎和物化视图构建数据管道"></a><a href="https://mp.weixin.qq.com/s?__biz=MzA4MDIwNTY4MQ==&mid=2247484250&idx=1&sn=4c2a9938afc2024287364bbe2d9be1de&chksm=9fa68144a8d10852fd6692a676a43c826b250384bf71828ab58269fd3424e353db51ffb0f1c0&cur_album_id=1342290453848326144&scene=190#rd">利用Null引擎和物化视图构建数据管道</a></h3><p>首先新建一张结果表，这是最终面向业务查询的表，使用 AggregatingMergeTree 表引擎:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE ch_label_string(<br>  labelname <span class="hljs-keyword">String</span>,<br>  labelvalue <span class="hljs-keyword">String</span>,<br>  uv AggregateFunction(groupBitmap,UInt64)<br>  <br>)ENGINE = AggregatingMergeTree()<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (labelname,labelvalue)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> labelname<br></code></pre></td></tr></table></figure><p>其中 uv 字段是 AggregateFunction(groupBitmap,UInt64) 类型。</p><p>接着用 Null 引擎新建一张和 ch_label_string 一样的镜像表:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> TABLE ch_label_string_null(<br>  labelname <span class="hljs-keyword">String</span>,<br>  labelvalue <span class="hljs-keyword">String</span>,<br>  uv UInt64<br>) Engine = <span class="hljs-literal">Null</span>;<br></code></pre></td></tr></table></figure><p>在这张表中，uv 字段使用普通的 UInt64。</p><p>Null 引擎和 Unix 系统的空设备 &#x2F;dev&#x2F;null 很像，向它写入的数据都会被丢弃掉。</p><p>接着重头戏来了，新建一张物化视图:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">MATERIALIZED</span> <span class="hljs-keyword">VIEW</span> ch_label_string_queue <span class="hljs-keyword">TO</span> ch_label_string <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span><br>    labelname,<br>    labelvalue,<br>    groupBitmapState(uv) <span class="hljs-keyword">AS</span> uv<br><span class="hljs-keyword">FROM</span> ch_label_string_null<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>    labelname,<br>    labelvalue<br></code></pre></td></tr></table></figure><p>这里使用了如下的语法:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">MATERIALIZED</span> <span class="hljs-keyword">VIEW</span> xxx <span class="hljs-keyword">TO</span> dest_table<br></code></pre></td></tr></table></figure><p>这样一来，该物化视图的作用就如同数据管道一般，每当 ch_label_string_null<br>有数据写入，就会按照 SELECT 语句源源不断的把数据写入到 ch_label_string。</p><p>在数据写入的时候，我们直接面向 ch_label_string_null 写入，并通过物化视图，直接将数据写入到了目标的 ch_label_string 这张表。</p><p>而ch_label_string_null 由于是 Null 引擎，本身不会存储任何多余的数据。</p><p>在数据查询的时候，我们则直接面向结果表  ch_label_string。</p><h3 id="如何在ClickHouse中快速实现AB表切换"><a href="#如何在ClickHouse中快速实现AB表切换" class="headerlink" title="如何在ClickHouse中快速实现AB表切换"></a><a href="https://mp.weixin.qq.com/s?__biz=MzA4MDIwNTY4MQ==&mid=2247484281&idx=1&sn=0c40e8d93c6f7981175e88d9abd7152c&chksm=9fa68167a8d1087115041e4b3755cb01e6b886ba5a01f91304e476395a7b0ee5a31b14225e30&cur_album_id=1342290453848326144&scene=190#rd">如何在ClickHouse中快速实现AB表切换</a></h3><ul><li>第一种是利用 RENAME 语法</br></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">RENAME <span class="hljs-selector-tag">TABLE</span> <span class="hljs-selector-tag">A</span> <span class="hljs-selector-tag">TO</span> C, <span class="hljs-selector-tag">B</span> <span class="hljs-selector-tag">TO</span> <span class="hljs-selector-tag">A</span>, C <span class="hljs-selector-tag">TO</span> <span class="hljs-selector-tag">B</span><br></code></pre></td></tr></table></figure><p> 虽然很方便，但也存在一定的风险，因为利用到了中间临时表，所以整个过程不是原子的，如果出现意外可能会导致不一致的情况发生，于是 ClickHouse 提供了第二种方式。</p><ul><li>第二种是利用 EXCHANGE TABLES 语法<br>首先新建一个 Atomic 数据库</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> test_atom ENGINE = Atomic<br></code></pre></td></tr></table></figure><p>直接用 EXCHANGE TABLES 交换两张表，这个操作是原子的。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">EXCHANGE TABLES test_atom.目标表 AND test_atom.原来表<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>EXCHANGE TABLES 的原子性是利用了底层系统的 renameat2 命令。它只有至少在 linux kernel 3.15 的操作系统上才能支持。</p><h3 id="String低基数字段优化"><a href="#String低基数字段优化" class="headerlink" title="String低基数字段优化"></a><a href="https://mp.weixin.qq.com/s?__biz=MzA4MDIwNTY4MQ==&mid=2247483881&idx=1&sn=a3ce7924bfcce51ed38ce1d2bd7c4518&chksm=9fa683f7a8d10ae1c0e22c9b61a9105fef011e56e2e2d53aa0992155f0ec7942ef25f6321287&cur_album_id=1342290453848326144&scene=190#rd">String低基数字段优化</a></h3><p>  ClickHouse提供了一种修饰数据类型LowCardinality，专门针对低基数特征的字段进行优化。</p><p>虽然LowCardinality的初衷是为了优化String，但是一不做二不休，LowCardinality目前还可以支持Int、Date和DateTime类型。</p><p>(主要在String场景使用，优化效果更明显)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">LowCardinality</span><span class="hljs-params">(String)</span></span><br><span class="hljs-function"><span class="hljs-title">LowCardinality</span><span class="hljs-params">(UInt32)</span></span><br><span class="hljs-function"><span class="hljs-title">LowCardinality</span><span class="hljs-params">(Date)</span></span><br></code></pre></td></tr></table></figure><p>那么LowCardinality背后的原理是什么呢?  其实从StringWithDictionary的名字已经很明显了，它是通过字典压缩编码进行优化的。</p><p>在默认的情况下，声明了LowCardinality的字段会基于数据生成一个全局字典，并利用倒排索引建立Key和位置的对应关系。如果数据的基数大于 8192，也就是说不同的值多于8192个，则会将一个全局字典拆分成多个局部字典(由 low_cardinality_max_dictionary_size 参数控制, 默认8192)。</p><p>因为进一步使用了字典压缩，所以查询的IO压力变小了，这是一处优化; 其次在处理数据的某些场合，可以直接使用字典进行操作，不需要将数据全部展开。</p>]]></content>
    
    
    <categories>
      
      <category>ClickHouse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ClickHouse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>G1垃圾回收器日志分析</title>
    <link href="/2022/11/03/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    <url>/2022/11/03/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="G1日志分析"><a href="#G1日志分析" class="headerlink" title="G1日志分析"></a>G1日志分析</h1><h2 id="新生代-young-GC-日志"><a href="#新生代-young-GC-日志" class="headerlink" title="新生代 young GC 日志"></a>新生代 young GC 日志</h2><p>G1使用 <code>-XX:PrintGCDetails</code>打印出详细的垃圾收集日志<br><img src="https://i.imgur.com/C752vCd.jpg" alt="C752vCd"></p><h3 id="一、四个关键信息"><a href="#一、四个关键信息" class="headerlink" title="一、四个关键信息"></a>一、四个关键信息</h3><ul><li>新生代垃圾收集发生的时间——<strong>2016-12-12T10:40:18.811-0500</strong>，通过设置<code>-XX:+PrintGCDateStamps</code>参数可以打印出这个时间；</li><li>JVM启动后的相对时间——<strong>25.959</strong></li><li>这次收集的类型——新生代收集，只回收Eden分区</li><li>这次收集花费的时间——<strong>0.0305171s，即30ms</strong></li></ul><h3 id="二、列出了新生代收集中并行收集的详细过程"><a href="#二、列出了新生代收集中并行收集的详细过程" class="headerlink" title="二、列出了新生代收集中并行收集的详细过程"></a>二、列出了新生代收集中并行收集的详细过程</h3><ul><li><strong>Parallel Time</strong>：并行收集任务在运行过程中引发的STW（Stop The World）时间，从新生代垃圾收集开始到最后一个任务结束，共花费26.6ms</li><li><strong>GC Workers</strong>：有4个线程负责垃圾收集，通过参数<code>-XX:ParallelGCThreads</code>设置，这个参数的值的设置，跟CPU有关，如果物理CPU支持的线程个数小于8，则最多设置为8；如果物理CPU支持的线程个数大于8，则默认值为number * 5&#x2F;8</li><li><strong>GC Worker Start</strong>：第一个垃圾收集线程开始工作时JVM启动后经过的时间（min）；最后一个垃圾收集线程开始工作时JVM启动后经过的时间（max）；diff表示min和max之间的差值。理想情况下，你希望他们几乎是同时开始，即diff趋近于0。</li><li><strong>Ext Root Scanning</strong>：扫描root集合（线程栈、JNI、全局变量、系统表等等）花费的时间，扫描root集合是垃圾收集的起点，尝试找到是否有root集合中的节点指向当前的收集集合（CSet）</li><li><strong>Update RS(Remembered Set or RSet)<strong>：每个分区都有自己的RSet，用来记录其他分区指向当前分区的指针，如果RSet有更新，G1中会有一个post-write barrier管理跨分区的引用——新的被引用的card会被标记为dirty，并放入一个日志缓冲区，如果这个日志缓冲区满了会被加入到一个全局的缓冲区，在JVM运行的过程中还有线程在并发处理这个全局日志缓冲区的dirty card。</strong>Update RS</strong>表示允许垃圾收集线程处理本次垃圾收集开始前没有处理好的日志缓冲区，这可以确保当前分区的RSet是最新的。<ul><li><strong>Processed Buffers</strong>，这表示在Update RS这个过程中处理多少个日志缓冲区。</li></ul></li><li><strong>Scan RS</strong>：扫描每个新生代分区的RSet，找出有多少指向当前分区的引用来自CSet。</li><li><strong>Code Root Scanning</strong>：扫描代码中的root节点（局部变量）花费的时间</li><li><strong>Object Copy</strong>：在疏散暂停期间，所有在CSet中的分区必须被转移疏散，Object Copy就负责将当前分区中存活的对象拷贝到新的分区。</li><li><strong>Termination</strong>：当一个垃圾收集线程完成任务时，它就会进入一个临界区，并尝试帮助其他垃圾线程完成任务（steal outstanding tasks），min表示该垃圾收集线程什么时候尝试terminatie，max表示该垃圾收集回收线程什么时候真正terminated。<ul><li><strong>Termination Attempts</strong>：如果一个垃圾收集线程成功盗取了其他线程的任务，那么它会再次盗取更多的任务或再次尝试terminate，每次重新terminate的时候，这个数值就会增加。</li></ul></li><li><strong>GC Worker Other</strong>：垃圾收集线程在完成其他任务的时间</li><li><strong>GC Worker Total</strong>：展示每个垃圾收集线程的最小、最大、平均、差值和总共时间。</li><li><strong>GC Worker End</strong>：min表示最早结束的垃圾收集线程结束时该JVM启动后的时间；max表示最晚结束的垃圾收集线程结束时该JVM启动后的时间。理想情况下，你希望它们快速结束，并且最好是同一时间结束。</li></ul><h3 id="三、列出了新生代GC中的一些任务："><a href="#三、列出了新生代GC中的一些任务：" class="headerlink" title="三、列出了新生代GC中的一些任务："></a>三、列出了新生代GC中的一些任务：</h3><ul><li><strong>Code Root Fixup</strong> ：释放用于管理并行垃圾收集活动的数据结构，应该接近于0，该步骤是线性执行的；</li><li><strong>Code Root Purge</strong>：清理更多的数据结构，应该很快，耗时接近于0，也是线性执行。</li><li><strong>Clear CT</strong>：清理card table</li></ul><h3 id="四、包含一些扩展功能"><a href="#四、包含一些扩展功能" class="headerlink" title="四、包含一些扩展功能"></a>四、包含一些扩展功能</h3><ul><li><strong>Choose CSet</strong>：选择要进行回收的分区放入CSet（G1选择的标准是垃圾最多的分区优先，也就是存活对象率最低的分区优先）</li><li><strong>Ref Proc</strong>：处理Java中的各种引用——soft、weak、final、phantom、JNI等等。</li><li><strong>Ref Enq</strong>：遍历所有的引用，将不能回收的放入pending列表</li><li><strong>Redirty Card</strong>：在回收过程中被修改的card将会被重置为dirty</li><li><strong>Humongous Register</strong>：JDK8u60提供了一个特性，巨型对象可以在新生代收集的时候被回收——通过<code>G1ReclaimDeadHumongousObjectsAtYoungGC</code> 设置，默认为true。</li><li><strong>Humongous Reclaim</strong>：做下列任务的时间：确保巨型对象可以被回收、释放该巨型对象所占的分区，重置分区类型，并将分区还到free列表，并且更新空闲空间大小。</li><li><strong>Free CSet</strong>：将要释放的分区还回到free列表。</li></ul><h3 id="五、展示了不同代的大小变化，以及堆大小的自适应调整。"><a href="#五、展示了不同代的大小变化，以及堆大小的自适应调整。" class="headerlink" title="五、展示了不同代的大小变化，以及堆大小的自适应调整。"></a>五、展示了不同代的大小变化，以及堆大小的自适应调整。</h3><ul><li>**Eden:1097.0M(1097.0M)-&gt;0.0B(967.0M)**：（1）当前新生代收集触发的原因是Eden空间满了，分配了1097M，使用了1097M；（2）所有的Eden分区都被疏散处理了，在新生代结束后Eden分区的使用大小成为了0.0B；（3）Eden分区的大小缩小为967.0M</li><li><strong>Survivors:13.0M-&gt;139.0M</strong>：由于年轻代分区的回收处理，survivor的空间从13.0M涨到139.0M；</li><li>**Heap:1694.4M(2048.0M)-&gt;736.3M(2048.0M)**：（1）在本次垃圾收集活动开始的时候，堆空间整体使用量是1694.4M，堆空间的最大值是2048M；（2）在本次垃圾收集结束后，堆空间的使用量是763.4M，最大值保持不变。</li></ul><h3 id="六、展示了本次新生代垃圾收集的时间"><a href="#六、展示了本次新生代垃圾收集的时间" class="headerlink" title="六、展示了本次新生代垃圾收集的时间"></a>六、展示了本次新生代垃圾收集的时间</h3><ul><li><strong>user&#x3D;0.8</strong>：垃圾收集线程在新生代垃圾收集过程中消耗的CPU时间，这个时间跟垃圾收集线程的个数有关，可能会比real time大很多；</li><li><strong>sys&#x3D;0.0</strong>：内核态线程消耗的CPU时间</li><li><strong>-real&#x3D;0.03</strong>：本次垃圾收集真正消耗的时间；</li></ul><h2 id="并发垃圾收集"><a href="#并发垃圾收集" class="headerlink" title="并发垃圾收集"></a>并发垃圾收集</h2><p>G1的第二种收集活动是并发垃圾收集，并发垃圾收集的触发条件有很多，但是做的工作都相同，它的日志如下图所示：</p><p><img src="https://i.imgur.com/XjrIhnA.jpg" alt="XjrIhnA"></p><h3 id="一、标志着并发垃圾收集阶段的开始"><a href="#一、标志着并发垃圾收集阶段的开始" class="headerlink" title="一、标志着并发垃圾收集阶段的开始"></a>一、标志着并发垃圾收集阶段的开始</h3><ul><li>**GC pause(G1 Evacuation Pause)(young)(initial-mark)**：为了充分利用STW的机会来trace所有可达（存活）的对象，initial-mark阶段是作为新生代垃圾收集中的一部分存在的（搭便车）。initial-mark设置了两个TAMS（top-at-mark-start）变量，用来区分存活的对象和在并发标记阶段新分配的对象。在TAMS之前的所有对象，在当前周期内都会被视作存活的。</li></ul><h3 id="二、表示第并发标记阶段做的第一个事情：根分区扫描"><a href="#二、表示第并发标记阶段做的第一个事情：根分区扫描" class="headerlink" title="二、表示第并发标记阶段做的第一个事情：根分区扫描"></a>二、表示第并发标记阶段做的第一个事情：根分区扫描</h3><ul><li><strong>GC concurrent-root-region-scan-start</strong>：根分区扫描开始，根分区扫描主要扫描的是新的survivor分区，找到这些分区内的对象指向当前分区的引用，如果发现有引用，则做个记录；</li><li><strong>GC concurrent-root-region-scan-end</strong>：根分区扫描结束，耗时0.0030613s</li></ul><h3 id="三、表示并发标记阶段"><a href="#三、表示并发标记阶段" class="headerlink" title="三、表示并发标记阶段"></a>三、表示并发标记阶段</h3><ul><li><p><strong>GC Concurrent-mark-start</strong>：并发标记阶段开始。（1）并发标记阶段的线程是跟应用线程一起运行的，不会STW，所以称为并发；并发标记阶段的垃圾收集线程，默认值是Parallel Thread个数的25%，这个值也可以用参数<code>-XX:ConcGCThreads</code>设置；（2）trace整个堆，并使用位图标记所有存活的对象，因为在top TAMS之前的对象是隐式存活的，所以这里只需要标记出那些在top TAMS之后、阈值之前的；（3）记录在并发标记阶段的变更，G1这里使用了SATB算法，该算法要求在垃圾收集开始的时候给堆做一个快照，在垃圾收集过程中这个快照是不变的，但实际上肯定有些对象的引用会发生变化，这时候G1使用了pre-write barrier记录这种变更，并将这个记录存放在一个SATB缓冲区中，如果该缓冲区满了就会将它加入到一个全局的缓冲区，同时G1有一个线程在并行得处理这个全局缓冲区；（4）在并发标记过程中，会记录每个分区的存活对象占整个分区的大小的比率；</p></li><li><p><strong>GC Concurrent-mark-end</strong>：并发标记阶段结束，耗时0.3055438s</p></li></ul><h3 id="四、重新标记阶段，会Stop-the-World"><a href="#四、重新标记阶段，会Stop-the-World" class="headerlink" title="四、重新标记阶段，会Stop the World"></a>四、重新标记阶段，会Stop the World</h3><ul><li><strong>Finalize Marking</strong>：Finalizer列表里的Finalizer对象处理，耗时0.0014099s；</li><li><strong>GC ref-proc</strong>：引用（soft、weak、final、phantom、JNI等等）处理，耗时0.0000480s；</li><li><strong>Unloading</strong>：类卸载，耗时0.0025840s；</li><li>除了前面这几个事情，这个阶段最关键的结果是：绘制出当前并发周期中整个堆的最后面貌，剩余的SATB缓冲区会在这里被处理，所有存活的对象都会被标记；</li></ul><h3 id="五、清理阶段，也会Stop-the-World"><a href="#五、清理阶段，也会Stop-the-World" class="headerlink" title="五、清理阶段，也会Stop the World"></a>五、清理阶段，也会Stop the World</h3><ul><li>计算出最后存活的对象：标记出initial-mark阶段后分配的对象；标记出至少有一个存活对象的分区；</li><li>为下一个并发标记阶段做准备，previous和next位图会被清理；</li><li>没有存活对象的老年代分区和巨型对象分区会被释放和清理；</li><li>处理没有任何存活对象的分区的RSet；</li><li>所有的老年代分区会按照自己的存活率（存活对象占整个分区大小的比例）进行排序，为后面的CSet选择过程做准备；</li></ul><h3 id="六、并发清理阶段"><a href="#六、并发清理阶段" class="headerlink" title="六、并发清理阶段"></a>六、并发清理阶段</h3><ul><li><strong>GC concurrent-cleanup-start</strong>：并发清理阶段启动。完成第5步剩余的清理工作；将完全清理好的分区加入到二级free列表，等待最终还会到总体的free列表；</li><li><strong>GC concurrent-cleanup-end</strong>：并发清理阶段结束，耗时0.0012954s</li></ul><h2 id="混合收集"><a href="#混合收集" class="headerlink" title="混合收集"></a>混合收集</h2><p>在并发收集阶段结束后，你会看到混合收集阶段的日志，如下图所示，该日志的大部分跟之前讨论的新生代收集相同，只有第1部分不一样：<strong>GC pause(G1 Evacuation Pause)(mixed),0.0129474s</strong>，这一行表示这是一个混合垃圾收集周期；在混合垃圾收集处理的CSet不仅包括新生代的分区，还包括老年代分区——也就是并发标记阶段标记出来的那些老年代分区。<br><img src="https://i.imgur.com/65ua0ft.jpg" alt="65ua0ft"></p><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>如果堆内存空间不足以分配新的对象，或者是Metasapce空间使用率达到了设定的阈值，那么就会触发Full GC——你在使用G1的时候应该尽量避免这种情况发生，因为G1的Full Gc是单线程、会Stop The World，代价非常高。Full GC的日志如下图所示，从中你可以看出三类信息</p><ol><li>Full GC的原因，这个图里是Allocation Failure，还有一个常见的原因是Metadata GC Threshold；</li><li>Full GC发生的频率，每隔几天发生一次Full GC还可以接受，但是每隔1小时发生一次Full GC则不可接受；</li><li>Full GC的耗时，这张图里的Full GC耗时150ms（PS：按照我的经验，实际运行中如果发生Full GC，耗时会比这个多很多）<br><img src="https://i.imgur.com/bYnho4q.jpg" alt="bYnho4q"></li></ol><p>基础配置参数中，我这里还想介绍两个：<code>-XX:+PrintGCApplicationStoppedTime</code>和<code>-XX:+PrintGCApplicationConcurrentTime</code>，这两个参数也可以为你提供有用的信息，如下图所示：<br><img src="https://i.imgur.com/PX6KMgo.jpg" alt="PX6KMgo"></p><ol><li>记录了应用线程在安全点被暂停的总时间（也就是STW的总时间）</li><li>记录了让所有应用线程进入安全点所花费的总时间</li><li>记录了在两个安全点之间应用线程运行的时间</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T07:<span class="hljs-number">08</span>:<span class="hljs-number">23.683</span>+<span class="hljs-number">0000</span>: <span class="hljs-number">13004.683</span>: <span class="hljs-selector-attr">[GC pause (G1 Humongous Allocation) (young) , 0.0255329 secs]</span>  <span class="hljs-comment">// young GC</span><br>   <span class="hljs-selector-attr">[Parallel Time: 21.5 ms, GC Workers: 1]</span>    <span class="hljs-comment">// 并行8个线程，耗时21.5ms</span><br>      <span class="hljs-selector-attr">[GC Worker Start (ms):  13004683.5]</span><br>      <span class="hljs-selector-attr">[Ext Root Scanning (ms):  14.3]</span>   <span class="hljs-comment">// 扫描 root 的线程耗时</span><br>      <span class="hljs-selector-attr">[Update RS (ms):  1.6]</span><br>         <span class="hljs-selector-attr">[Processed Buffers:  40]</span>   <span class="hljs-comment">// Processed Buffers就是记录引用变化的缓存空间</span><br>      <span class="hljs-selector-attr">[Scan RS (ms):  0.2]</span>   <span class="hljs-comment">// 扫描 RS</span><br>      <span class="hljs-selector-attr">[Code Root Scanning (ms):  0.2]</span>   <span class="hljs-comment">// 根扫描耗时</span><br>      <span class="hljs-selector-attr">[Object Copy (ms):  4.7]</span>   <span class="hljs-comment">// 对象拷贝</span><br>      <span class="hljs-selector-attr">[Termination (ms):  0.0]</span><br>         <span class="hljs-selector-attr">[Termination Attempts:  1]</span><br>      <span class="hljs-selector-attr">[GC Worker Other (ms):  0.0]</span><br>      <span class="hljs-selector-attr">[GC Worker Total (ms):  21.0]</span>   <span class="hljs-comment">// GC 线程耗时</span><br>      <span class="hljs-selector-attr">[GC Worker End (ms):  13004704.5]</span><br>   <span class="hljs-selector-attr">[Code Root Fixup: 0.0 ms]</span><br>   <span class="hljs-selector-attr">[Code Root Purge: 0.0 ms]</span><br>   <span class="hljs-selector-attr">[Clear CT: 0.2 ms]</span>   <span class="hljs-comment">// 清空 CardTable 耗时，RS 是依赖 CardTable 记录区域存活对象的</span><br>   <span class="hljs-selector-attr">[Other: 3.9 ms]</span><br>      <span class="hljs-selector-attr">[Choose CSet: 0.0 ms]</span>   <span class="hljs-comment">// 选取 CSet</span><br>      <span class="hljs-selector-attr">[Ref Proc: 3.2 ms]</span>   <span class="hljs-comment">// 弱引用、软引用的处理耗时</span><br>      <span class="hljs-selector-attr">[Ref Enq: 0.0 ms]</span>   <span class="hljs-comment">// 弱引用、软引用的入队耗时</span><br>      <span class="hljs-selector-attr">[Redirty Cards: 0.1 ms]</span><br>      <span class="hljs-selector-attr">[Humongous Register: 0.1 ms]</span><br>      <span class="hljs-selector-attr">[Humongous Reclaim: 0.0 ms]</span><br>      <span class="hljs-selector-attr">[Free CSet: 0.2 ms]</span>    <span class="hljs-comment">// 释放被回收区域的耗时</span><br>   <span class="hljs-selector-attr">[Eden: 373.0M(395.0M)-&gt;0.0B(380.0M) Survivors: 1024.0K-&gt;14.0M Heap: 1189.9M(1408.0M)-&gt;830.5M(1408.0M)]</span>   <span class="hljs-comment">// 显示了堆的大小变化, Eden 从 373.0M 下降到 0, Survivors 从 1024.0K 上升到 14.0M，Heap 内存从 1189.9M 下降到  830.5M</span><br> <span class="hljs-selector-attr">[Times: user=0.03 sys=0.00, real=0.03 secs]</span> <br><span class="hljs-number">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T07:<span class="hljs-number">08</span>:<span class="hljs-number">23.708</span>+<span class="hljs-number">0000</span>: <span class="hljs-number">13004.709</span>: <span class="hljs-selector-attr">[GC concurrent-root-region-scan-start]</span>   <span class="hljs-comment">// 根区域扫描</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T07:<span class="hljs-number">08</span>:<span class="hljs-number">23.713</span>+<span class="hljs-number">0000</span>: <span class="hljs-number">13004.713</span>: <span class="hljs-selector-attr">[GC concurrent-root-region-scan-end, 0.0048903 secs]</span>   <br><span class="hljs-number">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T07:<span class="hljs-number">08</span>:<span class="hljs-number">23.713</span>+<span class="hljs-number">0000</span>: <span class="hljs-number">13004.713</span>: <span class="hljs-selector-attr">[GC concurrent-mark-start]</span>    <span class="hljs-comment">// 并发标记</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T07:<span class="hljs-number">08</span>:<span class="hljs-number">23.872</span>+<span class="hljs-number">0000</span>: <span class="hljs-number">13004.872</span>: <span class="hljs-selector-attr">[GC concurrent-mark-end, 0.1585816 secs]</span> <br><span class="hljs-number">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T07:<span class="hljs-number">08</span>:<span class="hljs-number">23.933</span>+<span class="hljs-number">0000</span>: <span class="hljs-number">13004.933</span>: <span class="hljs-selector-attr">[GC remark 2021-03-18T07:08:23.933+0000: 13004.933: [Finalize Marking, 0.0002291 secs]</span> <span class="hljs-number">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T07:<span class="hljs-number">08</span>:<span class="hljs-number">23.933</span>+<span class="hljs-number">0000</span>: <span class="hljs-number">13004.934</span>: <span class="hljs-selector-attr">[GC ref-proc, 0.0080423 secs]</span> <span class="hljs-number">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T07:<span class="hljs-number">08</span>:<span class="hljs-number">23.941</span>+<span class="hljs-number">0000</span>: <span class="hljs-number">13004.942</span>: <span class="hljs-selector-attr">[Unloading, 0.0703731 secs]</span>, <span class="hljs-number">0.0852099</span> secs]<br> <span class="hljs-selector-attr">[Times: user=0.09 sys=0.00, real=0.09 secs]</span> <br><span class="hljs-number">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T07:<span class="hljs-number">08</span>:<span class="hljs-number">24.019</span>+<span class="hljs-number">0000</span>: <span class="hljs-number">13005.019</span>: <span class="hljs-selector-attr">[GC cleanup 851M-&gt;764M(1408M), 0.0027544 secs]</span><br> <span class="hljs-selector-attr">[Times: user=0.00 sys=0.00, real=0.00 secs]</span> <br><span class="hljs-number">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T07:<span class="hljs-number">08</span>:<span class="hljs-number">24.022</span>+<span class="hljs-number">0000</span>: <span class="hljs-number">13005.022</span>: <span class="hljs-selector-attr">[GC concurrent-cleanup-start]</span>   <span class="hljs-comment">// 重新标记又叫最终标记</span><br><span class="hljs-number">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T07:<span class="hljs-number">08</span>:<span class="hljs-number">24.022</span>+<span class="hljs-number">0000</span>: <span class="hljs-number">13005.022</span>: <span class="hljs-selector-attr">[GC concurrent-cleanup-end, 0.0000804 secs]</span><br></code></pre></td></tr></table></figure><h2 id="老年代-Full-GC-日志"><a href="#老年代-Full-GC-日志" class="headerlink" title="老年代 Full GC 日志"></a>老年代 Full GC 日志</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-number">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">19</span>T02:<span class="hljs-number">08</span>:<span class="hljs-number">52.178</span>+<span class="hljs-number">0000</span>: <span class="hljs-number">81433.178</span>: [F<span class="hljs-function"><span class="hljs-title">ull</span> GC (Allocation Failure)  1331M-&gt;</span><span class="hljs-number">1190</span>M(<span class="hljs-number">1408</span>M), <span class="hljs-number">0.3951381</span> secs]   <span class="hljs-comment">// Full GC 失败, 其原因是空间分配失败(Allocation Failure)</span><br>   [E<span class="hljs-function"><span class="hljs-title">den</span>: 0.0B(68.0M)-&gt;</span><span class="hljs-number">0.0</span>B(<span class="hljs-number">70.0</span>M) S<span class="hljs-function"><span class="hljs-title">urvivors</span>: 2048.0K-&gt;</span><span class="hljs-number">0.0</span>B H<span class="hljs-function"><span class="hljs-title">eap</span>: 1331.5M(1408.0M)-&gt;</span><span class="hljs-number">1190.0</span>M(<span class="hljs-number">1408.0</span>M)], [M<span class="hljs-function"><span class="hljs-title">etaspace</span>: 595088K-&gt;</span><span class="hljs-number">593735</span>K(<span class="hljs-number">1597440</span>K)]   <span class="hljs-comment">// 显示了堆的大小变化</span><br> [Times: user=<span class="hljs-number">0.40</span> sys=<span class="hljs-number">0.00</span>, <span class="hljs-keyword">real</span>=<span class="hljs-number">0.39</span> secs]    <span class="hljs-comment">// 表示 GC 总共花了 0.39 秒</span><br></code></pre></td></tr></table></figure><blockquote><p>Full GC (Allocation Failure) 的一般原因：老年代存活的对象太多，基本没有被回收。</p></blockquote><h1 id="G1-调优"><a href="#G1-调优" class="headerlink" title="G1 调优"></a>G1 调优</h1><h2 id="避免设置年轻代的大小"><a href="#避免设置年轻代的大小" class="headerlink" title="避免设置年轻代的大小"></a><strong>避免设置年轻代的大小</strong></h2><p>防止使用 -Xmn、-XX:NewRatio 指定年轻代大小，如果指定固定的年轻代大小，则会覆盖最大暂停时间目标，得不偿失。</p><h2 id="期望的最大暂停时间"><a href="#期望的最大暂停时间" class="headerlink" title="期望的最大暂停时间"></a><strong>期望的最大暂停时间</strong></h2><p>权衡延迟与吞吐量。最大暂停时间设置较小，可能需要较大的 GC 开销，反之则只需较小的 GC 开销。</p><h2 id="GC-日志中内存耗尽的信息"><a href="#GC-日志中内存耗尽的信息" class="headerlink" title="GC 日志中内存耗尽的信息"></a>GC 日志中内存耗尽的信息</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T03:<span class="hljs-number">31</span>:<span class="hljs-number">46</span>.<span class="hljs-number">969</span>+<span class="hljs-number">0000</span>: <span class="hljs-number">7</span>.<span class="hljs-number">969</span>:<span class="hljs-meta"> [GC pause (G1 Evacuation Pause) (young), 0.0376195 secs]</span><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T07:<span class="hljs-number">03</span>:<span class="hljs-number">34</span>.<span class="hljs-number">443</span>+<span class="hljs-number">0000</span>: <span class="hljs-number">12715</span>.<span class="hljs-number">443</span>:<span class="hljs-meta"> [GC pause (G1 Evacuation Pause) (mixed), 0.0141364 secs]</span><br></code></pre></td></tr></table></figure><blockquote><p>解决该问题的策略：<br>● 增加 -XX:G1ReservePercent，以增加保留的 “to-space” 大小，堆内存一般也相应需要增加。<br>● 降低 -XX:InitiatingHeapOccupancyPercent 来尽早触发标记周期。<br>● 适当加大 -XX:ConcGCThreads 选项的值，增加并发标记的线程数。</p></blockquote><h2 id="巨型对象的内存分配"><a href="#巨型对象的内存分配" class="headerlink" title="巨型对象的内存分配"></a><strong>巨型对象的内存分配</strong></h2><blockquote><p>背景：如果某个对象超过单个 Region 空间的一半，则会被 G1 视为巨型对象，例如大数组和字符串。巨型对象会直接分配到老年代的 Humongous 区。</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2021</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">18</span>.<span class="hljs-number">826</span>+<span class="hljs-number">0000</span>: <span class="hljs-number">17919</span>.<span class="hljs-number">826</span>:<span class="hljs-meta"> [GC pause (G1 Humongous Allocation) (young), 0.0664334 secs]</span><br></code></pre></td></tr></table></figure><p>如果在 GC 日志中，看到由 Humongous 分配触发的大量 GC，导致在老年代形成大量的内存碎片。需要增加 -XX:G1HeapRegionSize，即对象小于 Region 的 50%，让之前的大对象不再被直接分配到 Humongous 区，而是走常规的对象分配方式。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.redhat.com/en/blog/collecting-and-reading-g1-garbage-collector-logs-part-2?source=author&term=22991">Collecting and reading G1 garbage collector logs</a></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java日常问题诊断方法</title>
    <link href="/2022/10/22/Java%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD%E6%96%B9%E6%B3%95/"/>
    <url>/2022/10/22/Java%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="日志检索"><a href="#日志检索" class="headerlink" title="日志检索"></a>日志检索</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 检索 exception 关键字或 error 关键字</span><br><br><span class="hljs-attribute">grep</span> -E <span class="hljs-string">&quot;exception|error&quot;</span> app.log<br><br><span class="hljs-comment"># 显示关键字上下 10 行日志</span><br><br><span class="hljs-attribute">grep</span> -C <span class="hljs-number">10</span> exception app.log<br><br><span class="hljs-comment"># 检索 2020-05-05 19:23~25  分钟段日志</span><br><br><span class="hljs-attribute">grep</span> &#x27;<span class="hljs-number">2020</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">19</span>:<span class="hljs-number">2</span>[<span class="hljs-number">3</span>-<span class="hljs-number">5</span>]&#x27; app.log<br><br><span class="hljs-attribute">sed</span> -n &#x27;/<span class="hljs-number">2020</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">19</span>:<span class="hljs-number">23</span>/,/<span class="hljs-number">2020</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">19</span>:<span class="hljs-number">25</span>/p&#x27; app.log<br><br><span class="hljs-comment"># 检索 2020-05-05 19:23:10~15 秒段日志</span><br><br><span class="hljs-attribute">grep</span> &#x27;<span class="hljs-number">2020</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">19</span>:<span class="hljs-number">23</span>:[<span class="hljs-number">10</span>-<span class="hljs-number">15</span>]&#x27; app.log<br><br><span class="hljs-attribute">sed</span> -n &#x27;/<span class="hljs-number">2020</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">19</span>:<span class="hljs-number">23</span>:<span class="hljs-number">10</span>/,/<span class="hljs-number">2020</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">19</span>:<span class="hljs-number">23</span>:<span class="hljs-number">15</span>/p&#x27; app.log<br><br><span class="hljs-comment"># 查询 /data 目录下大于 500m 的文件</span><br><br><span class="hljs-attribute">find</span> /data -type f -size +<span class="hljs-number">500</span>M<br></code></pre></td></tr></table></figure><h1 id="CPU-amp-Load"><a href="#CPU-amp-Load" class="headerlink" title="CPU &amp; Load"></a>CPU &amp; Load</h1><h2 id="CPU-User高-amp-Load高"><a href="#CPU-User高-amp-Load高" class="headerlink" title="CPU User高 &amp; Load高"></a>CPU User高 &amp; Load高</h2><p>User：CPU 在用户态空间（用户进程）的运行时间比例。</p><p>常见原因与排查方法：</p><ol><li><p>代码中存在非常消耗 CPU 的操作</p><ul><li>找出对应的 Java 进程 pid <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> java    <br></code></pre></td></tr></table></figure></li><li>找出 Java 进程中最消耗 CPU 的线程 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">top</span> -H -<span class="hljs-selector-tag">p</span> &lt;pid&gt;<br></code></pre></td></tr></table></figure></li><li>将找出的线程 id 转换为 16 进制 <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;%x\n&quot;</span> pid<br></code></pre></td></tr></table></figure></li><li>jstack 获取 Java 的线程堆栈</li><li>根据 16 进制的 id 从线程堆栈中找到相关的堆栈信息</li></ul></li><li><p>频繁 GC</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">jstat</span> -<span class="hljs-variable">gcutil</span> <span class="hljs-variable">pid</span> <span class="hljs-function"><span class="hljs-title">interval</span>(<span class="hljs-variable">ms</span>)</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="CPU-System高-amp-Load高"><a href="#CPU-System高-amp-Load高" class="headerlink" title="CPU System高 &amp; Load高"></a>CPU System高 &amp; Load高</h2><p>System：CPU 在内核态空间的运行时间比例。例如内存分配、IO 读写、线程创建和切换等。</p><p>常见原因：</p><ol><li>并发锁竞争严重</li><li>线程频繁切换</li></ol><p>排查方法：</p><ol><li><p>jstack 打印线程堆栈，整体统计线程状态，如 WAITING、TIMED_WAITING、BLOCKED。</p></li><li><p>pidstat -w<br>可以查看 CPU 上下文切换的状态。cswch&#x2F;s 每秒自愿上下文切换次数：进程无法获取资源，如内存、IO 等；nvcswch&#x2F;s 每秒非自愿上下文切换次数：时间片耗尽系统强制调度，如进程频繁争抢 CPU。</p></li></ol><p>常用优化方法：</p><ol><li>优化锁粒度范围。</li><li>使用无锁的数据结构，例如 RingBuffer。</li><li>死锁的解决方法之一就是破坏请求和保持条件，所以等待&#x2F;通知机制可以避免循环等待的 CPU 消耗。</li></ol><h2 id="CPU-Wait高-amp-Load高-amp-CPU利用率低"><a href="#CPU-Wait高-amp-Load高-amp-CPU利用率低" class="headerlink" title="CPU Wait高 &amp; Load高 &amp; CPU利用率低"></a>CPU Wait高 &amp; Load高 &amp; CPU利用率低</h2><p>CPU is idle while waiting for an I&#x2F;O operation to complete。The time the CPU spends in this state is shown by the wait statistic.</p><p>CPU 等待磁盘写入的时间。当 CPU 发起 IO 读写操作后，需要等待磁盘数据加载至内存。</p><p>常见原因：</p><ul><li>IO 操作频繁</li><li>资源未及时释放造成泄漏</li></ul><p>排查方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看设备的 IO 状态</span><br><br>iostat -x 2<br><br>参数含义：<br><br>rrqm/s : 每秒合并读操作的次数<br>wrqm/s: 每秒合并写操作的次数<br>r/s ：每秒读操作的次数<br>w/s : 每秒写操作的次数<br>rKB/s :每秒读取字节数<br>wKB/s: 每秒写入字节数<br>avgrq-sz：平均每次 IO 的数据大小，以扇区（512字节）为单位<br>avgqu-sz：平均 IO 请求队列长度<br>await：平均每个IO所需要的时间，包括在队列等待的时间和请求处理的时间。<br>r_wait：每个读操作平均所需要的时间，包括硬盘设备读操作的时间 + 内核队列中的时间。<br>w_wait: 每个写操平均所需要的时间，包括硬盘设备写操作的时间 + 队列中等待的时间。<br>%util: 每秒内用于 I/O 操作的时间占比<br><br><span class="hljs-comment"># 查找引起 iowait 高的进程</span><br><br>iotop<br><br><span class="hljs-comment"># 查看引起 iowait 高的具体文件</span><br><br>lsof -p &lt;pid&gt;<br></code></pre></td></tr></table></figure><p>常用解决与优化方法：</p><ul><li>有效控制资源数量，例如使用线程池等。</li><li>了解磁盘特性是必要的，一般随机写转顺序写，同步写转异步写，IO 合并都可以得到较好的改善。</li><li>压缩 &amp; Dirty Page 优化。Linux 操作系统中，当 Dirty Page 的大小达到总物理内存大小 10%，操作系统会进行刷盘但不阻塞系统调用的写线程，若达到物理内存大小的 20%，写线程会被阻塞。通过合适的压缩算法减少落盘数据的大小通常效果显著。</li><li>预读取和读缓存。</li><li>Zero Copy。</li><li>MMap 内存映射。</li><li>硬件红利。</li></ul><h1 id="内存-amp-GC"><a href="#内存-amp-GC" class="headerlink" title="内存 &amp; GC"></a>内存 &amp; GC</h1><p>常用排查工具：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment"># 内存整体情况</span><br><br>free -m <br><br><span class="hljs-comment"># JVM 堆内存占用排行</span><br><br>jmap -histo &lt;<span class="hljs-keyword">pid</span>&gt; | head -n <span class="hljs-number">30</span><br><br><span class="hljs-comment"># JVM 内存占用信息</span><br><br>jstat -gccause &lt;<span class="hljs-keyword">pid</span>&gt; <span class="hljs-number">1000</span> <span class="hljs-number">1000</span><br>jstat -gcutil &lt;<span class="hljs-keyword">pid</span>&gt;<br><br><span class="hljs-comment"># dump内存</span><br><br>jmap -F -dump:live,<span class="hljs-keyword">file</span>=/home/admin/heap.bin &lt;<span class="hljs-keyword">pid</span>&gt;<br></code></pre></td></tr></table></figure><h1 id="进程消失-amp-OutOfMemoryError"><a href="#进程消失-amp-OutOfMemoryError" class="headerlink" title="进程消失 &amp; OutOfMemoryError"></a>进程消失 &amp; OutOfMemoryError</h1><p>进程消失大部分跟 OOM Killer 有关，可以根据 dmesg -T 查看系统日志。</p><p>OOM 常见原因与排查方法：</p><ol><li><p>Java heap space &#x2F; GC overhead limit exceeded &#x2F; CMS GC、Full GC 频繁</p><ul><li>启动参数增加 -XX:+HeapDumpOnOutOfMemoryError，可在 OOM 时保存 Dump 文件。</li><li>jmap Dump 内存文件</li><li>MAT 分析 HeapDump 文件，找到内存泄漏的代码。例如一直在分配内存而引用未释放，缓存的数据结构未做保护限制等。</li></ul></li><li><p>java.lang.StackOverflowError</p><ul><li>最常见：深层次或者无限递归。</li><li>函数调用层级深。</li><li>栈上分配较大的缓存。可适当调整 -Xss 大小。</li><li>循环依赖。</li></ul></li><li><p>PermGen Space &#x2F; Meta space</p><ul><li>超过 -XX:MaxMetaspaceSize 设置的大小，如果确实不够用可以适当调整大小。</li><li>排查代码中是否有类似 javassist 动态生成 class 的逻辑。</li></ul></li><li><p>DirectBuffer</p><ul><li>监控：MXBean 可以获取堆外内存使用情况。</li><li>Netty 自带检测工具：-Dio.netty.leakDetectionLevel&#x3D;[检测级别]</li><li>Btrace 神器：ByteBuffer.allocateDirect</li><li>堆外内存泄漏情况比较复杂，尽可能在本地模拟复现，二分定位也是个有效的版本。参考 Netty堆外内存泄露排查盛宴，排查思路非常值得借鉴学习。</li><li>jmap -histo:live<br> 手动触发 FullGC, 观察堆外内存是否被回收，如果正常回收很可能是因为堆外设置太小，可以通过 -XX:MaxDirectMemorySize 调整。当然这无法排除堆外内存缓慢泄漏的情况。</li><li>堆外内存泄漏：Java 中是通过 ByteBuffer.allocateDirect 分配堆外内存。</li><li>网络流量大，系统被短时间打爆。可以通过扩容、限流等手段解决。</li></ul></li><li><p>unable to create new native thread</p><ul><li>ps 等操作 Linux 会出现 Resource temporarily unavailable 错误。</li><li>修改 &#x2F;etc&#x2F;security&#x2F;limits.conf 配置。</li></ul></li><li><p>MMap</p><ul><li>MAP_SHARED、MAP_PRIVATE、MAP_ANONYMOUS、MAP_NORESERVE，在不同的模式下表现行为不同，例如常用的 MAP_PRIVATE，如果程序没有及时释放资源会遭遇 OOM Killer。</li><li>MMap 的文件数量超过了 vm.max_map_count 限制。</li></ul></li></ol><h1 id="服务假死-amp-超时"><a href="#服务假死-amp-超时" class="headerlink" title="服务假死 &amp; 超时"></a>服务假死 &amp; 超时</h1><p>常见原因与解决方法：</p><ol><li><p>死锁</p><ul><li>jstack 分析线程堆栈</li></ul></li><li><p>线程池耗尽</p><ul><li>扩大线程池数量</li><li>避免处理时间过长的业务逻辑</li><li>降低超时时间</li></ul></li><li><p>客户端或者服务端频繁 GC</p><ul><li>System.gc() 或者 jmap -histo:live 主动触发</li><li>PermGen Space &#x2F; Meta space 空间不足</li><li>YGC 晋升到老年代的平均大小大于老年代剩余空间</li><li>CMS GC 中 Remark 时间长：可通过 CMSScavengeBeforeRemark 参数保证 Remark 前进行一次 Minor GC</li><li>promotion failed：对象晋升的目标区域没有足够的空间</li><li>concurrent mode failure：CMS GC 的过程的同时业务进程申请老年代空间，而此时老年代空间不足导致。</li><li>大对象分配失败，视 GC 算法不同可优化不同的参数，如 -XX:G1HeapRegionSize</li><li>YGC 频繁：可通过 -Xmn 调整新生代大小，-XX:SurvivorRatio 设置 SurvivorRatio 和 eden 区比例。应该清楚程序中对象的基本分布情况，如果存在大量朝生夕灭的对象，应适当调大新生代；反之应适当调大老年代。</li><li>YGC 时间长：常见有两个原因年轻代存活对象太多；老年代引用年轻代对象太多（跨代引用）。</li><li>Stop-The-World GC</li></ul></li><li><p>网络异常</p><ul><li>重点关注 CLOSE_WAIT，可能连接未关闭导致资源消耗殆尽。</li><li><code>netstat -nt</code> 查看 TCP 相关连接状态、连接数以及发送队列和接收队列。正常的连接应该是 ESTABLISHED 状态，如果存在大量的 SYN_SENT 的连接，则需要看下防火墙规则。<strong>如果 Recv-Q 或者 Send-Q 持续有大量包存在，意味着连接存在瓶颈或者程序存在 bug。</strong></li></ul></li><li><p>客户端或者服务端 CPU 使用率高，排查方法同 CPU 相关小节。</p></li><li><p>对象未序列化，检查是否实现 Serializable 序列化接口等。</p></li></ol><h1 id="ClassLoader-amp-Jar包冲突"><a href="#ClassLoader-amp-Jar包冲突" class="headerlink" title="ClassLoader &amp; Jar包冲突"></a>ClassLoader &amp; Jar包冲突</h1><p>JVM 装载 jar 包时，加载顺序完全取决于操作系统，所以在不同的环境有可能表现出来的问题不一样。</p><p>常见问题：</p><ul><li>NoSuchMethodException</li><li>ClassNotFoundException</li><li>NoClassDefFoundError</li><li>ClassCastException</li></ul><p>常用解决方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># 打印所有依赖</span><br><br>mvn <span class="hljs-symbol">dependency:</span>tree<br><br><span class="hljs-comment"># 只查看关注的依赖</span><br><br>mvn <span class="hljs-symbol">dependency:</span>tree -Dverbose -Dincludes=&lt;groupId&gt;<span class="hljs-symbol">:&lt;artifactId&gt;</span><br><br><span class="hljs-comment"># 观察类的加载过程</span><br><br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+TraceClassLoading</span><br><br>-<span class="hljs-symbol">verbose:</span><span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://mp.weixin.qq.com/s/q5S5mj2IkW7RMpD3k45teg">工具百宝箱（1）— Java日常问题诊断方法</a></p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GC调优与问题排查合集</title>
    <link href="/2022/10/20/GC%E8%B0%83%E4%BC%98%E4%B8%8E%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%90%88%E9%9B%86/"/>
    <url>/2022/10/20/GC%E8%B0%83%E4%BC%98%E4%B8%8E%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、调优"><a href="#一、调优" class="headerlink" title="一、调优"></a>一、调优</h1><p><a href="https://mp.weixin.qq.com/s/_B6yCptCa49xzWNEcYhSDw">高并发场景下JVM调优实践之路</a></p><h1 id="二、问题排查"><a href="#二、问题排查" class="headerlink" title="二、问题排查"></a>二、问题排查</h1><h2 id="一次夜间接口超时的解决过程"><a href="#一次夜间接口超时的解决过程" class="headerlink" title="一次夜间接口超时的解决过程"></a><a href="https://mp.weixin.qq.com/s/g_Y323V4fvUKqvTGhs5VyQ">一次夜间接口超时的解决过程</a></h2><blockquote><p>摘要：<br><font color = red>本次Store加载是在业务线程池加载，对所有Future都只等待1s，1s加载不完立刻就返回了，不可能有8s的耗时。而且机器已经是16G容器，又没有FGC导致的STW。</font> 那就只有<strong>进程级别</strong>的hang会影响到多个线程了。<br>用到的命令 <code>pmap</code> 和 <code>sar</code></p></blockquote><h2 id="没有二十年功力，写不出这一行“看似无用”的代码！"><a href="#没有二十年功力，写不出这一行“看似无用”的代码！" class="headerlink" title="没有二十年功力，写不出这一行“看似无用”的代码！"></a><a href="https://mp.weixin.qq.com/s/AhoTKmXfRW0RDC3rS5SZcw">没有二十年功力，写不出这一行“看似无用”的代码！</a></h2><blockquote><p>摘要：<br>Safepoint导致长时间STW</p></blockquote><h2 id="好了，别问了，确实是被优化了！"><a href="#好了，别问了，确实是被优化了！" class="headerlink" title="好了，别问了，确实是被优化了！"></a><a href="https://mp.weixin.qq.com/s/T333wsXPyvOMCaEwMmKq0Q">好了，别问了，确实是被优化了！</a></h2><blockquote><p>摘要：<br>对安全点的解释文章<br><a href="http://psy-lob-saw.blogspot.com/2015/12/safepoints.html">Safepoints: Meaning, Side Effects and Overheads</a><br><a href="http://psy-lob-saw.blogspot.com/2016/02/wait-for-it-counteduncounted-loops.html">Wait For It: Counted&#x2F;Uncounted loops, Safepoints and OSR Compilation</a></p></blockquote><h2 id="一次-Young-GC-的优化实践（FinalReference-相关）"><a href="#一次-Young-GC-的优化实践（FinalReference-相关）" class="headerlink" title="一次 Young GC 的优化实践（FinalReference 相关）"></a><a href="https://mp.weixin.qq.com/s/AnAZ4Vsu2S1CSIBqt-XGTQ">一次 Young GC 的优化实践（FinalReference 相关）</a></h2><blockquote><p>摘要：<br>YoungGC 效率低;Young GC 是全程 stop the world 的，时间可能有多方面原因决定：</p><ul><li>各个线程到达安全点的等待时间；</li><li>从 GC Root 扫描对象，进行标记的时间；</li><li>存活对象 copy 到 Survivor 以及晋升 Old Gen 到的时间；</li><li>GC 日志的时间。</li></ul></blockquote><h2 id="JVM调优实战：G1中的to-space-exhausted问题"><a href="#JVM调优实战：G1中的to-space-exhausted问题" class="headerlink" title="JVM调优实战：G1中的to-space exhausted问题"></a><a href="https://mp.weixin.qq.com/s/cbCGNg1bXTeG_7E8NgwLbA">JVM调优实战：G1中的to-space exhausted问题</a></h2><blockquote><p>摘要：<br>老区不够了，这个时候会把young区所有对象不管死活都转成old区对象，所以总的内存使用量会暴增。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2022/10/16/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2022/10/16/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/2022/10/16/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.gif" class="" title="图片引用方法一">]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
